import os
import requests
import logging
import sys
import time
import threading
import subprocess
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from sqlalchemy import create_engine, Column, String, DateTime, Integer
from sqlalchemy.orm import declarative_base, sessionmaker
from groq import Groq
# openai„ÅØ„Ç§„É≥„Éù„Éº„Éà„É™„Çπ„Éà„Å´„ÅÇ„Çä„Åæ„Åô„Åå‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„ÄÅ„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„Éà„Åæ„Åü„ÅØÂâäÈô§„ÇÇÂèØËÉΩ„Åß„Åô
# from openai import OpenAI 

# „É≠„Ç∞Ë®≠ÂÆö„ÇíË©≥Á¥∞„Å´
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- ÊúÄÈÅ©ÂåñË®≠ÂÆö ---
VOICEVOX_MAX_TEXT_LENGTH = 50
VOICEVOX_FAST_TIMEOUT = 10
VOICEVOX_WORKERS = 2

# --- Èü≥Â£∞„Éï„Ç°„Ç§„É´‰øùÂ≠òË®≠ÂÆö (‰øÆÊ≠£ÁÇπ) ---
VOICE_DIR = '/tmp/voices'

# --- Èü≥Â£∞„Ç≠„É£„ÉÉ„Ç∑„É•Ë®≠ÂÆö ---
voice_cache = {}
CACHE_MAX_SIZE = 100
cache_lock = threading.Lock()

# --- Secret File„Åã„Çâ„ÅÆË®≠ÂÆöË™≠„ÅøËæº„Åø ---
def get_secret(name):
    secret_file = f'/etc/secrets/{name}'
    try:
        with open(secret_file, 'r') as f:
            value = f.read().strip()
            logger.info(f"Secret File„Åã„ÇâGOT {name[:4]}***„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇ")
            return value
    except FileNotFoundError:
        logger.warning(f"Secret File '{secret_file}' „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇÁí∞Â¢ÉÂ§âÊï∞„ÇíË©¶„Åó„Åæ„Åô„ÄÇ")
        return os.environ.get(name)
    except Exception as e:
        logger.error(f"{name} „ÅÆË™≠„ÅøËæº„Åø‰∏≠„Å´„Ç®„É©„Éº: {e}")
        return None

DATABASE_URL = get_secret('DATABASE_URL')
GROQ_API_KEY = get_secret('GROQ_API_KEY')
VOICEVOX_URL_FROM_ENV = get_secret('VOICEVOX_URL')

# --- Âº∑Âåñ„Åï„Çå„ÅüVOICEVOXÊé•Á∂ö„ÉÜ„Çπ„Éà ---
VOICEVOX_URLS = [
    'http://localhost:50021',
    'http://127.0.0.1:50021',
    'http://voicevox-engine:50021',
    'http://voicevox:50021'
]

def check_system_processes():
    logger.info("üîç „Ç∑„Çπ„ÉÜ„É†Ë®∫Êñ≠ÈñãÂßã")
    try:
        ps_result = subprocess.run(['ps', 'aux'], capture_output=True, text=True, timeout=5)
        voicevox_processes = [line for line in ps_result.stdout.split('\n') if 'voicevox' in line.lower()]
        if voicevox_processes:
            logger.info(f"üîç VOICEVOX„Éó„É≠„Çª„ÇπÁô∫Ë¶ã: {len(voicevox_processes)}ÂÄã")
            for proc in voicevox_processes[:3]:
                logger.info(f"   {proc}")
        else:
            logger.warning("üîç VOICEVOX„Éó„É≠„Çª„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
    except Exception as e:
        logger.error(f"üîç „Éó„É≠„Çª„ÇπÁ¢∫Ë™ç„Ç®„É©„Éº: {e}")

# --- find_working_voicevox_url (‰øÆÊ≠£Ê∏à„Åø„ÅÆÈñ¢Êï∞) ---
def find_working_voicevox_url():
    """Âº∑Âåñ„Åï„Çå„ÄÅÁ∞°Áï•Âåñ„Åï„Çå„ÅüVOICEVOX URLÊ§úÁ¥¢"""
    logger.info("üöÄ VOICEVOX URLÊ§úÁ¥¢ÈñãÂßã")
    check_system_processes()
    
    urls_to_test = []
    if VOICEVOX_URL_FROM_ENV:
        urls_to_test.insert(0, VOICEVOX_URL_FROM_ENV)
    urls_to_test.extend([url for url in VOICEVOX_URLS if url not in urls_to_test])
    
    logger.info(f"üß™ „ÉÜ„Çπ„ÉàÂØæË±°URL: {len(urls_to_test)}ÂÄã")
    
    for i, url in enumerate(urls_to_test, 1):
        logger.info(f"üì° ({i}/{len(urls_to_test)}) „ÉÜ„Çπ„ÉàÈñãÂßã: {url}")
        
        try:
            # Step 1: „Éê„Éº„Ç∏„Éß„É≥„ÉÅ„Çß„ÉÉ„ÇØ
            logger.info(f"   „Çπ„ÉÜ„ÉÉ„Éó1: GET {url}/version")
            version_response = requests.get(f"{url}/version", timeout=5)
            if version_response.status_code != 200:
                logger.warning(f"   ‚ùå „Éê„Éº„Ç∏„Éß„É≥„ÉÅ„Çß„ÉÉ„ÇØÂ§±Êïó: {version_response.status_code}")
                continue # Ê¨°„ÅÆURL„Å∏

            version_info = version_response.json()
            version = version_info if isinstance(version_info, str) else version_info.get('version', 'unknown')
            logger.info(f"   ‚úÖ „Éê„Éº„Ç∏„Éß„É≥: v{version}")
            
            # Step 2: „Çπ„Éî„Éº„Ç´„Éº„É™„Çπ„Éà„ÉÅ„Çß„ÉÉ„ÇØ
            logger.info(f"   „Çπ„ÉÜ„ÉÉ„Éó2: GET {url}/speakers")
            speakers_response = requests.get(f"{url}/speakers", timeout=5)
            if speakers_response.status_code == 200:
                speakers = speakers_response.json()
                logger.info(f"   ‚úÖ „Çπ„Éî„Éº„Ç´„Éº„É™„Çπ„ÉàÂèñÂæóÊàêÂäü ({len(speakers)}ÂÄã)")
                logger.info(f"üéØ VOICEVOX URLÊ±∫ÂÆö: {url}")
                return url # ‚òÖ‚òÖ‚òÖ „Åì„Åì„ÅßÊàêÂäü„Å®„Åø„Å™„Åó„ÄÅURL„ÇíËøî„Åó„Å¶ÁµÇ‰∫Ü ‚òÖ‚òÖ‚òÖ
            else:
                logger.warning(f"   ‚ùå „Çπ„Éî„Éº„Ç´„Éº„É™„Çπ„ÉàÂèñÂæóÂ§±Êïó: {speakers_response.status_code}")
                
        except requests.exceptions.Timeout as e:
            logger.warning(f"   ‚è∞ „Çø„Ç§„É†„Ç¢„Ç¶„Éà: {e}")
        except requests.exceptions.ConnectionError as e:
            logger.warning(f"   üîå Êé•Á∂ö„Ç®„É©„Éº: {e}")
        except Exception as e:
            logger.error(f"   ‚ùå ‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº: {e}")
            
    logger.error("‚ùå Âà©Áî®ÂèØËÉΩ„Å™VOICEVOX URL„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
    return None

# --- ÂàùÊúüÂåñÂá¶ÁêÜ ---
logger.info("=" * 50)
logger.info("VOICEVOXÂàùÊúüÂåñÈñãÂßã")
WORKING_VOICEVOX_URL = find_working_voicevox_url()
if WORKING_VOICEVOX_URL:
    logger.info(f"‚úÖ VOICEVOXÂàùÊúüÂåñÊàêÂäü: {WORKING_VOICEVOX_URL}")
else:
    logger.error("‚ùå VOICEVOXÂàùÊúüÂåñÂ§±Êïó")
logger.info("=" * 50)

# --- ÂøÖÈ†àÂ§âÊï∞„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ ---
if not DATABASE_URL or not GROQ_API_KEY:
    logger.critical("FATAL: ÂøÖÈ†àÁí∞Â¢ÉÂ§âÊï∞„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ")
    sys.exit(1)

# --- Flask„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂàùÊúüÂåñ ---
app = Flask(__name__)
CORS(app, origins=["*"], methods=["GET", "POST", "OPTIONS"])

# --- „Çµ„Éº„Éì„ÇπÂàùÊúüÂåñ ---
groq_client = None
try:
    groq_client = Groq(api_key=GROQ_API_KEY)
    groq_client.chat.completions.create(
        messages=[{"role": "user", "content": "Hi"}], 
        model="llama3-8b-8192", max_tokens=3
    )
    logger.info("‚úÖ Groq API - OK")
except Exception as e:
    logger.error(f"‚ùå Groq APIÂàùÊúüÂåñÂ§±Êïó: {e}")

# --- „Éá„Éº„Çø„Éô„Éº„ÇπË®≠ÂÆö ---
Base = declarative_base()
class UserMemory(Base):
    __tablename__ = 'user_memories'
    id = Column(Integer, primary_key=True)
    user_uuid = Column(String(255), unique=True, nullable=False)
    user_name = Column(String(255), nullable=False)
    interaction_count = Column(Integer, default=0)

try:
    engine = create_engine(DATABASE_URL, pool_pre_ping=True)
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    logger.info("‚úÖ „Éá„Éº„Çø„Éô„Éº„Çπ - OK")
except Exception as e:
    logger.critical(f"FATAL: „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂öÂ§±Êïó: {e}")
    sys.exit(1)

# --- „É¶„Éº„Ç∂„Éº„Éá„Éº„ÇøÂá¶ÁêÜ ---
class UserDataContainer:
    def __init__(self, user_uuid, user_name, interaction_count):
        self.user_uuid = user_uuid
        self.user_name = user_name
        self.interaction_count = interaction_count

def get_or_create_user(user_uuid, user_name):
    session = Session()
    try:
        user_memory = session.query(UserMemory).filter_by(user_uuid=user_uuid).first()
        if user_memory:
            user_memory.interaction_count += 1
        else:
            user_memory = UserMemory(user_uuid=user_uuid, user_name=user_name, interaction_count=1)
            session.add(user_memory)
        session.commit()
        return UserDataContainer(
            user_uuid=user_memory.user_uuid,
            user_name=user_memory.user_name,
            interaction_count=user_memory.interaction_count
        )
    finally:
        session.close()

# --- AIÂøúÁ≠îÁîüÊàê ---
def generate_ai_response(user_data, message):
    if not groq_client: return f"{user_data.user_name}„Åï„Çì„ÄÅ„Åì„Çì„Å´„Å°„ÅØÔºÅ"
    system_prompt = f"„ÅÇ„Å™„Åü„ÅØ„Äå„ÇÇ„Å°„Åì„Äç„Åß„Åô„ÄÇ{user_data.user_name}„Åï„Çì„Å®Ë©±„Åó„Åæ„Åô„ÄÇ40ÊñáÂ≠ó‰ª•ÂÜÖ„ÅßË¶™„Åó„Åø„ÇÑ„Åô„ÅèËøî‰∫ã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË™ûÂ∞æ„Äå„Åß„Åô„Çè„Äç„Äå„Åæ„Åô„Çè„Äç„ÄÅ‰∏Ä‰∫∫Áß∞„Äå„ÅÇ„Å¶„ÅÉ„Åó„Äç"
    try:
        completion = groq_client.chat.completions.create(
            messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": message or "„Åì„Çì„Å´„Å°„ÅØ"}], 
            model="llama3-8b-8192", temperature=0.8, max_tokens=80
        )
        return completion.choices[0].message.content.strip()
    except Exception as e:
        logger.error(f"AIÂøúÁ≠î„Ç®„É©„Éº: {e}")
        return f"{user_data.user_name}„Åï„Çì„ÄÅ„Å°„Çá„Å£„Å®ËÄÉ„Åà‰∏≠„Åß„Åô„ÇèÔºÅ"

# --- Èü≥Â£∞„Ç≠„É£„ÉÉ„Ç∑„É•Ê©üËÉΩ ---
def get_cache_key(text, speaker_id): return f"{hash(text)}_{speaker_id}"
def get_cached_voice(text, speaker_id):
    with cache_lock: return voice_cache.get(get_cache_key(text, speaker_id))
def cache_voice(text, speaker_id, voice_data):
    with cache_lock:
        if len(voice_cache) >= CACHE_MAX_SIZE:
            del voice_cache[next(iter(voice_cache))]
        voice_cache[get_cache_key(text, speaker_id)] = voice_data

# --- Âº∑Âåñ„Åï„Çå„ÅüÈü≥Â£∞ÁîüÊàê (‰øÆÊ≠£Ê∏à„Åø„ÅÆÈñ¢Êï∞) ---
def generate_voice_fast(text, speaker_id=3):
    if not WORKING_VOICEVOX_URL:
        logger.warning("üö´ VOICEVOXÂà©Áî®‰∏çÂèØ - Èü≥Â£∞ÁîüÊàê„Çπ„Ç≠„ÉÉ„Éó")
        return None
        
    if len(text) > VOICEVOX_MAX_TEXT_LENGTH:
        text = text[:VOICEVOX_MAX_TEXT_LENGTH] + "..."
    
    if cached_voice := get_cached_voice(text, speaker_id):
        logger.info(f"üöÄ „Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„Éà: '{text[:20]}...'")
        return cached_voice
    
    logger.info(f"üéµ Èü≥Â£∞ÂêàÊàêÈñãÂßã: '{text}' (speaker:{speaker_id})")
    start_time = time.time()
    
    try:
        # Step 1: audio_query
        logger.info("   -> Step 1/2: audio_query")
        query_response = requests.post(
            f"{WORKING_VOICEVOX_URL}/audio_query", 
            params={'text': text, 'speaker': speaker_id}, 
            timeout=VOICEVOX_FAST_TIMEOUT
        )
        if query_response.status_code != 200:
            logger.error(f"‚ùå QueryÂ§±Êïó: {query_response.status_code} {query_response.text[:200]}")
            return None
        
        # Step 2: synthesis
        logger.info("   -> Step 2/2: synthesis")
        synthesis_response = requests.post(
            f"{WORKING_VOICEVOX_URL}/synthesis", 
            params={'speaker': speaker_id}, 
            json=query_response.json(), 
            timeout=VOICEVOX_FAST_TIMEOUT * 4  # ‚òÖ‚òÖ‚òÖ „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Çí40Áßí„Å´Âª∂Èï∑ ‚òÖ‚òÖ‚òÖ
        )
        if synthesis_response.status_code != 200:
            logger.error(f"‚ùå SynthesisÂ§±Êïó: {synthesis_response.status_code} {synthesis_response.text[:200]}")
            return None
            
        voice_data = synthesis_response.content
        logger.info(f"‚úÖ Èü≥Â£∞ÂêàÊàêÊàêÂäü: {time.time() - start_time:.2f}Áßí, {len(voice_data)}bytes")
        cache_voice(text, speaker_id, voice_data)
        return voice_data
        
    except Exception as e:
        logger.error(f"‚ùå Èü≥Â£∞ÂêàÊàê„Ç®„É©„Éº: {e}")
        return None

# --- „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà ---
@app.route('/')
def index():
    return jsonify({
        'service': '„ÇÇ„Å°„Åì AI Assistant (‰øÆÊ≠£Áâà)',
        'status': 'running',
        'voicevox_status': 'available' if WORKING_VOICEVOX_URL else 'unavailable',
        'voicevox_url': WORKING_VOICEVOX_URL
    })

# --- chat_lsl (‰øÆÊ≠£Ê∏à„Åø„ÅÆÈñ¢Êï∞) ---
@app.route('/chat_lsl', methods=['POST'])
def chat_lsl():
    try:
        data = request.json or {}
        user_uuid = data.get('uuid')
        user_name = data.get('name')
        message = data.get('message', '')
        
        if not (user_uuid and user_name): return "Error: uuid and name required", 400
        
        logger.info(f"üì® „ÉÅ„É£„ÉÉ„ÉàÂèó‰ø°: {user_name} ({user_uuid[:8]}...) - '{message[:30]}...'")
        user_data = get_or_create_user(user_uuid, user_name)
        ai_text = generate_ai_response(user_data, message)
        logger.info(f"ü§ñ AIÂøúÁ≠î: '{ai_text}'")
        
        voice_data = generate_voice_fast(ai_text, speaker_id=3)
        audio_url = ""
        
        if voice_data and len(voice_data) > 1000: # 1KBÊú™Ê∫Ä„ÅØÁÑ°Âäπ„Å™„Éá„Éº„Çø„Å®Ë¶ã„Å™„Åô
            try:
                # „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åô„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Éª„Å™„Åë„Çå„Å∞‰ΩúÊàê
                os.makedirs(VOICE_DIR, exist_ok=True)
                
                timestamp = int(time.time() * 1000)
                filename = f"voice_{user_uuid[:8]}_{timestamp}.wav"
                filepath = os.path.join(VOICE_DIR, filename)
                
                with open(filepath, 'wb') as f:
                    f.write(voice_data)
                
                if os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                    audio_url = f'/voice/{filename}'
                    logger.info(f"‚úÖ Èü≥Â£∞„Éï„Ç°„Ç§„É´‰øùÂ≠òÊàêÂäü: {filepath}")
                else:
                    logger.error(f"‚ùå Èü≥Â£∞„Éï„Ç°„Ç§„É´‰øùÂ≠òÊ§úË®ºÂ§±Êïó: {filepath}")
            except Exception as file_error:
                logger.error(f"‚ùå „Éï„Ç°„Ç§„É´‰øùÂ≠ò„Ç®„É©„Éº: {file_error}")
        else:
            logger.warning("Èü≥Â£∞„Éá„Éº„ÇøÁîüÊàêÂ§±Êïó„ÄÅ„Åæ„Åü„ÅØ„Éá„Éº„Çø„Çµ„Ç§„Ç∫„Åå‰∏çÂçÅÂàÜ„Åß„Åô„ÄÇ")

        response_text = f"{ai_text}|{audio_url}"
        return app.response_class(response=response_text, status=200, mimetype='text/plain; charset=utf-8')
        
    except Exception as e:
        logger.error(f"‚ùå „ÉÅ„É£„ÉÉ„Éà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Ç®„É©„Éº: {e}", exc_info=True)
        return "Error: Internal server error", 500

# --- serve_voice (‰øÆÊ≠£Ê∏à„Åø„ÅÆÈñ¢Êï∞) ---
@app.route('/voice/<filename>')
def serve_voice(filename):
    """Èü≥Â£∞„Éï„Ç°„Ç§„É´ÈÖç‰ø°"""
    try:
        logger.info(f"üìÅ Èü≥Â£∞„Éï„Ç°„Ç§„É´ÈÖç‰ø°Ë¶ÅÊ±Ç: {filename} from {VOICE_DIR}")
        if not os.path.exists(os.path.join(VOICE_DIR, filename)):
             logger.error(f"‚ùå ÈÖç‰ø°„Éï„Ç°„Ç§„É´‰∏çÂ≠òÂú®: {filename}")
             return "File not found", 404
        return send_from_directory(VOICE_DIR, filename)
    except Exception as e:
        logger.error(f"‚ùå Èü≥Â£∞„Éï„Ç°„Ç§„É´ÈÖç‰ø°„Ç®„É©„Éº: {e}")
        return "File not found", 404

# --- „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„Å®„Éá„Éê„ÉÉ„Ç∞Áî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà ---
@app.route('/health')
def health_check():
    return jsonify({'status': 'healthy', 'voicevox_url': WORKING_VOICEVOX_URL})

@app.route('/debug/voicevox_retry')
def debug_voicevox_retry():
    global WORKING_VOICEVOX_URL
    WORKING_VOICEVOX_URL = find_working_voicevox_url()
    return jsonify({'result': 'success' if WORKING_VOICEVOX_URL else 'failed', 'working_url': WORKING_VOICEVOX_URL})

# --- „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂÆüË°å ---
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    host = os.environ.get('HOST', '0.0.0.0')
    
    logger.info("üöÄ „ÇÇ„Å°„ÅìAI (‰øÆÊ≠£Áâà) Ëµ∑Âãï")
    logger.info(f"üåç http://{host}:{port}")
    logger.info(f"üéµ VOICEVOX: {'OK' if WORKING_VOICEVOX_URL else 'NG'} ({WORKING_VOICEVOX_URL or 'N/A'})")
    
    app.run(host=host, port=port, debug=False, threaded=True)
