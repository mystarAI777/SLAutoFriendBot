import os
import requests
import logging
import sys
import time
import threading
import subprocess
import json
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, request, jsonify, send_from_directory, send_file
from flask_cors import CORS
from sqlalchemy import create_engine, Column, String, DateTime, Integer
from sqlalchemy.orm import declarative_base, sessionmaker
from groq import Groq
import tempfile
from urllib.parse import quote, unquote
from duckduckgo_search import DDGS # <--- ‚òÖ ËøΩÂä†

# „É≠„Ç∞Ë®≠ÂÆö„ÇíË©≥Á¥∞„Å´
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- ÊúÄÈÅ©ÂåñË®≠ÂÆö ---
VOICEVOX_MAX_TEXT_LENGTH = 50
VOICEVOX_FAST_TIMEOUT = 10
VOICEVOX_WORKERS = 2

# --- Èü≥Â£∞„Éï„Ç°„Ç§„É´‰øùÂ≠òË®≠ÂÆö ---
VOICE_DIR = '/tmp/voices'

# --- Èü≥Â£∞„Ç≠„É£„ÉÉ„Ç∑„É•Ë®≠ÂÆö ---
voice_cache = {}
CACHE_MAX_SIZE = 100
cache_lock = threading.Lock()

# --- Secret File„Åã„Çâ„ÅÆË®≠ÂÆöË™≠„ÅøËæº„Åø ---
def get_secret(name):
    secret_file = f'/etc/secrets/{name}'
    try:
        with open(secret_file, 'r') as f:
            value = f.read().strip()
            logger.info(f"Secret File„Åã„ÇâGOT {name[:4]}***„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇ")
            return value
    except FileNotFoundError:
        logger.warning(f"Secret File '{secret_file}' „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇÁí∞Â¢ÉÂ§âÊï∞„ÇíË©¶„Åó„Åæ„Åô„ÄÇ")
        return os.environ.get(name)
    except Exception as e:
        logger.error(f"{name} „ÅÆË™≠„ÅøËæº„Åø‰∏≠„Å´„Ç®„É©„Éº: {e}")
        return None

DATABASE_URL = get_secret('DATABASE_URL')
GROQ_API_KEY = get_secret('GROQ_API_KEY')
VOICEVOX_URL_FROM_ENV = get_secret('VOICEVOX_URL')

# --- Âº∑Âåñ„Åï„Çå„ÅüVOICEVOXÊé•Á∂ö„ÉÜ„Çπ„Éà ---
VOICEVOX_URLS = [
    'http://localhost:50021',
    'http://127.0.0.1:50021',
    'http://voicevox-engine:50021',
    'http://voicevox:50021'
]

def check_system_processes():
    logger.info("üîç „Ç∑„Çπ„ÉÜ„É†Ë®∫Êñ≠ÈñãÂßã")
    try:
        pass
    except Exception:
        pass

def find_working_voicevox_url():
    logger.info("üöÄ VOICEVOX URLÊ§úÁ¥¢ÈñãÂßã")
    check_system_processes()
    urls_to_test = [url for url in ([VOICEVOX_URL_FROM_ENV] + VOICEVOX_URLS) if url]
    
    for url in urls_to_test:
        try:
            logger.info(f"üì° „ÉÜ„Çπ„ÉàÈñãÂßã: {url}")
            version_response = requests.get(f"{url}/version", timeout=5)
            if version_response.status_code != 200: continue
            
            speakers_response = requests.get(f"{url}/speakers", timeout=5)
            if speakers_response.status_code == 200:
                logger.info(f"üéØ VOICEVOX URLÊ±∫ÂÆö: {url}")
                return url
        except requests.exceptions.RequestException:
            continue
    logger.error("‚ùå Âà©Áî®ÂèØËÉΩ„Å™VOICEVOX URL„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
    return None

# --- ÂàùÊúüÂåñÂá¶ÁêÜ ---
WORKING_VOICEVOX_URL = find_working_voicevox_url()
logger.info(f"‚úÖ VOICEVOXÂàùÊúüÂåñÂÆå‰∫Ü: {WORKING_VOICEVOX_URL or 'Â§±Êïó'}")

# --- ÂøÖÈ†àÂ§âÊï∞„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Å®„Çµ„Éº„Éì„ÇπÂàùÊúüÂåñ ---
if not DATABASE_URL or not GROQ_API_KEY:
    logger.critical("FATAL: ÂøÖÈ†àÁí∞Â¢ÉÂ§âÊï∞„Åå‰∏çË∂≥„ÄÇ")
    sys.exit(1)

app = Flask(__name__)
CORS(app)
groq_client = Groq(api_key=GROQ_API_KEY)
engine = create_engine(DATABASE_URL)
Base = declarative_base()

class UserMemory(Base):
    __tablename__ = 'user_memories'
    id = Column(Integer, primary_key=True)
    user_uuid = Column(String(255), unique=True, nullable=False)
    user_name = Column(String(255), nullable=False)
    interaction_count = Column(Integer, default=0)

Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)

# --- ‚òÖ‚òÖ‚òÖ „Åì„Åì„Åã„ÇâWebÊ§úÁ¥¢Ê©üËÉΩ„ÅÆ‰øÆÊ≠£ ‚òÖ‚òÖ‚òÖ ---
def search_web(query, max_results_per_site=2):
    """
    Yahoo!„Éã„É•„Éº„Çπ„Å®Wikipedia„Åã„ÇâÊÉÖÂ†±„ÇíÊ§úÁ¥¢„Åó„ÄÅÁµêÊûú„ÇíË¶ÅÁ¥Ñ„Åó„Å¶Ëøî„Åô„ÄÇ
    """
    search_results = []
    sites = {
        "Yahoo!„Éã„É•„Éº„Çπ": "news.yahoo.co.jp",
        "Wikipedia": "ja.wikipedia.org"
    }

    try:
        with DDGS(timeout=10) as ddgs:
            for site_name, site_url in sites.items():
                search_query = f"{query} site:{site_url}"
                logger.info(f"üîç {site_name} „ÇíÊ§úÁ¥¢‰∏≠: '{search_query}'")
                
                # duckduckgo_search„ÅØ„Ç∏„Çß„Éç„É¨„Éº„Çø„ÇíËøî„Åô„Åì„Å®„Åå„ÅÇ„Çã„ÅÆ„Åß„É™„Çπ„Éà„Å´Â§âÊèõ
                results = list(ddgs.text(search_query, max_results=max_results_per_site))
                
                if results:
                    # ÁµêÊûú„ÅÆÊú¨ÊñáÔºàbodyÔºâ„ÇíÁµêÂêà„Åó„Å¶Ë¶ÅÁ¥Ñ„Çí‰ΩúÊàê
                    summary = " / ".join([r.get('body', '') for r in results])
                    search_results.append(f"„Äê{site_name}„Äë{summary[:250]}...") # Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÅØ250ÊñáÂ≠ó„Åß„Ç´„ÉÉ„Éà
    
    except Exception as e:
        logger.error(f"WebÊ§úÁ¥¢‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {e}", exc_info=True)
        return f"„Äå{query}„Äç„ÅÆÊ§úÁ¥¢‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"

    if not search_results:
        return f"„Äå{query}„Äç„Å´„Å§„ÅÑ„Å¶„ÄÅYahoo!„Éã„É•„Éº„Çπ„ÇÑWikipedia„Åß„ÅØÈñ¢ÈÄ£ÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ"
    
    # ÁµêÂêà„Åó„Å¶ÊúÄÁµÇÁöÑ„Å™Ê§úÁ¥¢ÁµêÊûúÊñáÂ≠óÂàó„Çí‰ΩúÊàê
    final_summary = "\n".join(search_results)
    logger.info(f"üìä ÊúÄÁµÇÁöÑ„Å™Ê§úÁ¥¢ÁµêÊûú„ÅÆË¶ÅÁ¥Ñ:\n{final_summary}")
    
    return final_summary
# --- ‚òÖ‚òÖ‚òÖ „Åì„Åì„Åæ„ÅßWebÊ§úÁ¥¢Ê©üËÉΩ„ÅÆ‰øÆÊ≠£ ‚òÖ‚òÖ‚òÖ ---


def should_search(message):
    """„É°„ÉÉ„Çª„Éº„Ç∏„ÅåWebÊ§úÁ¥¢„ÇíÂøÖË¶Å„Å®„Åô„Çã„Åã„ÇíÂà§ÂÆö"""
    search_keywords = [
        "ÊúÄÊñ∞", "„Éã„É•„Éº„Çπ", "‰ªäÊó•", "ÁèæÂú®", "„ÅÑ„Åæ", "„É™„Ç¢„É´„Çø„Ç§„É†",
        "Â§©Ê∞ó", "Ê†™‰æ°", "ÁÇ∫Êõø", "„Çπ„Éù„Éº„ÉÑ", "Ëä∏ËÉΩ", "ÊîøÊ≤ª",
        "Ë™ø„Åπ„Å¶", "Ê§úÁ¥¢", "ÊÉÖÂ†±", "„Å©„ÅÜ„Å™„Å£„Å¶„ÅÑ„Çã", "Áä∂Ê≥Å", "„Å®„ÅØ", "Ë™∞"
    ]
    # „Ç≠„Éº„ÉØ„Éº„Éâ„ÅÆ„ÅÑ„Åö„Çå„Åã„ÇíÂê´„Åø„ÄÅ„Åã„Å§Èï∑„Åô„Åé„Å™„ÅÑ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊ§úÁ¥¢ÂØæË±°„Å®„Åô„Çã
    return any(keyword in message for keyword in search_keywords) and len(message) < 50

class UserDataContainer:
    def __init__(self, user_uuid, user_name, interaction_count):
        self.user_uuid = user_uuid
        self.user_name = user_name
        self.interaction_count = interaction_count

def get_or_create_user(user_uuid, user_name):
    session = Session()
    try:
        user_memory = session.query(UserMemory).filter_by(user_uuid=user_uuid).first()
        if user_memory: 
            user_memory.interaction_count += 1
        else:
            user_memory = UserMemory(user_uuid=user_uuid, user_name=user_name, interaction_count=1)
            session.add(user_memory)
        session.commit()
        return UserDataContainer(user_memory.user_uuid, user_memory.user_name, user_memory.interaction_count)
    finally: 
        session.close()

def generate_ai_response(user_data, message):
    """WebÊ§úÁ¥¢ÁµêÊûú„ÇíÂê´„ÇÄAIÂøúÁ≠îÁîüÊàê"""
    search_info = ""
    
    if should_search(message):
        logger.info(f"üîç WebÊ§úÁ¥¢ÂÆüË°å: '{message}'")
        search_info = search_web(message) # ‰øÆÊ≠£„Åï„Çå„ÅüÊ§úÁ¥¢Èñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô
        if search_info:
            logger.info(f"üìä Ê§úÁ¥¢ÁµêÊûúÂèñÂæó: {search_info[:150]}...")
    
    system_prompt = f"""„ÅÇ„Å™„Åü„ÅØ„Äå„ÇÇ„Å°„Åì„Äç„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆË≥¢„ÅÑAI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ„É¶„Éº„Ç∂„Éº„ÅÆ„Äå{user_data.user_name}„Äç„Åï„Çì„Å®‰ºöË©±„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„ÅÇ„Å™„Åü„ÅØË¶™„Åó„Åø„ÇÑ„Åô„ÅÑ„ÇÆ„É£„É´Âè£Ë™ø„ÅßË©±„Åó„Åæ„Åô„ÄÇ„ÅÇ„Å™„ÅüËá™Ë∫´„ÇíÊåá„Åô„Å®„Åç„ÅØ„Äå„ÅÇ„Å¶„ÅÉ„Åó„Äç„Å®Ë®Ä„ÅÑ„Åæ„Åô„ÄÇ
ËøîÁ≠î„ÅØÂ∏∏„Å´„ÄÅÁ∞°ÊΩî„Åã„Å§Ë¶ÅÁÇπ„Çí„Åæ„Å®„ÇÅ„Å¶40ÊñáÂ≠ó‰ª•ÂÜÖ„ÅßÁ≠î„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

‰ª•‰∏ã„ÅÆWebÊ§úÁ¥¢ÁµêÊûú„ÇíÂèÇËÄÉ„Å´„Åó„Å¶„ÄÅË≥™Âïè„Å´Á≠î„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
---
{f'Ê§úÁ¥¢ÁµêÊûú: {search_info}' if search_info else 'Ê§úÁ¥¢ÁµêÊûú„Å™„Åó'}
---
"""

    try:
        completion = groq_client.chat.completions.create(
            messages=[
                {"role": "system", "content": system_prompt}, 
                {"role": "user", "content": message or "„Åì„Çì„Å´„Å°„ÅØ"}
            ],
            model="llama3-8b-8192", 
            temperature=0.8, 
            max_tokens=100,
            top_p=0.9,
        )
        return completion.choices[0].message.content.strip()
    except Exception as e:
        logger.error(f"AIÂøúÁ≠îÁîüÊàê„Ç®„É©„Éº: {e}")
        return "„ÅÇ„Å¶„ÅÉ„Åó„ÄÅ„Å°„Çá„Å£„Å®Ë™øÂ≠êÊÇ™„ÅÑ„Åã„ÇÇ...„Åæ„Åü„ÅÇ„Å®„ÅßË©±„ÅùÔºÅ"

def get_cache_key(text, speaker_id): 
    return f"{hash(text)}_{speaker_id}"

def get_cached_voice(text, speaker_id):
    with cache_lock: 
        return voice_cache.get(get_cache_key(text, speaker_id))

def cache_voice(text, speaker_id, voice_data):
    with cache_lock:
        if len(voice_cache) >= CACHE_MAX_SIZE: 
            del voice_cache[next(iter(voice_cache))]
        voice_cache[get_cache_key(text, speaker_id)] = voice_data

def generate_voice_fast(text, speaker_id=3):
    if not WORKING_VOICEVOX_URL: 
        return None
    if len(text) > VOICEVOX_MAX_TEXT_LENGTH: 
        text = text[:VOICEVOX_MAX_TEXT_LENGTH] + "..."
    if cached_voice := get_cached_voice(text, speaker_id): 
        return cached_voice
    
    try:
        query_response = requests.post(
            f"{WORKING_VOICEVOX_URL}/audio_query", 
            params={'text': text, 'speaker': speaker_id}, 
            timeout=VOICEVOX_FAST_TIMEOUT
        )
        query_response.raise_for_status()
        
        synthesis_response = requests.post(
            f"{WORKING_VOICEVOX_URL}/synthesis", 
            params={'speaker': speaker_id}, 
            json=query_response.json(), 
            timeout=VOICEVOX_FAST_TIMEOUT * 6
        )
        synthesis_response.raise_for_status()
        
        voice_data = synthesis_response.content
        cache_voice(text, speaker_id, voice_data)
        return voice_data
    except requests.exceptions.RequestException as e:
        logger.error(f"‚ùå Èü≥Â£∞ÂêàÊàê„É™„ÇØ„Ç®„Çπ„Éà„Ç®„É©„Éº: {e}")
        return None

voice_files = {}
voice_files_lock = threading.Lock()

def store_voice_file(filename, voice_data):
    try:
        os.makedirs(VOICE_DIR, exist_ok=True)
        filepath = os.path.join(VOICE_DIR, filename)
        with open(filepath, 'wb') as f: f.write(voice_data)
        with voice_files_lock:
            voice_files[filename] = {'data': voice_data, 'created_at': time.time(), 'filepath': filepath}
        logger.info(f"‚úÖ Èü≥Â£∞„Éï„Ç°„Ç§„É´‰øùÂ≠òÊàêÂäü: {filepath}")
        return True
    except Exception as e:
        logger.error(f"‚ùå Èü≥Â£∞„Éï„Ç°„Ç§„É´‰øùÂ≠ò„Ç®„É©„Éº: {e}")
        return False

def background_voice_generation(text, filename, speaker_id=3):
    logger.info(f"üé§ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈü≥Â£∞ÁîüÊàêÈñãÂßã: {filename}")
    voice_data = generate_voice_fast(text, speaker_id)
    if voice_data and len(voice_data) > 1000:
        if not store_voice_file(filename, voice_data):
            logger.error(f"‚ùå „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈü≥Â£∞‰øùÂ≠òÂ§±Êïó: {filename}")
    else:
        logger.warning(f"üé§ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈü≥Â£∞ÁîüÊàêÂ§±Êïó or „Éá„Éº„Çø„Çµ„Ç§„Ç∫‰∏çË∂≥: {filename}")

@app.route('/')
def index():
    return jsonify({
        'service': '„ÇÇ„Å°„Åì AI Assistant (Live with Yahoo/Wikipedia Search)',
        'status': 'running',
        'voicevox_status': 'available' if WORKING_VOICEVOX_URL else 'unavailable',
        'web_search_enabled': True,
        'timestamp': datetime.utcnow().isoformat()
    })

@app.route('/chat_lsl', methods=['POST'])
def chat_lsl():
    try:
        data = request.json or {}
        user_uuid, user_name, message = data.get('uuid'), data.get('name'), data.get('message', '')
        if not (user_uuid and user_name): return "Error: uuid and name required", 400
        
        logger.info(f"üì® „ÉÅ„É£„ÉÉ„ÉàÂèó‰ø°: {user_name} ({user_uuid[:8]}...) - '{message}'")
        
        user_data = get_or_create_user(user_uuid, user_name)
        ai_text = generate_ai_response(user_data, message)
        logger.info(f"ü§ñ AIÂøúÁ≠î: '{ai_text}'")
        
        audio_url = ""
        if WORKING_VOICEVOX_URL:
            filename = f"voice_{user_uuid[:8]}_{int(time.time() * 1000)}.wav"
            audio_url = f'/voice/{filename}'
            thread = threading.Thread(target=background_voice_generation, args=(ai_text, filename))
            thread.daemon = True
            thread.start()
            logger.info(f"üöÄ Èü≥Â£∞ÁîüÊàê„Çπ„É¨„ÉÉ„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü„ÄÇURL: {audio_url}")
        
        response_text = f"{ai_text}|{audio_url}"
        logger.info(f"üì§ Âç≥ÊôÇ„É¨„Çπ„Éù„É≥„ÇπÈÄÅ‰ø°: Text='{ai_text}', URL='{audio_url}'")
        
        return app.response_class(response=response_text, status=200, mimetype='text/plain; charset=utf-8')
        
    except Exception as e:
        logger.error(f"‚ùå „ÉÅ„É£„ÉÉ„Éà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Ç®„É©„Éº: {e}", exc_info=True)
        return "Error: Internal server error", 500

@app.route('/voice/<filename>')
def serve_voice(filename):
    try:
        with voice_files_lock:
            if filename in voice_files:
                voice_info = voice_files[filename]
                logger.info(f"üéµ „É°„É¢„É™„Åã„ÇâÈü≥Â£∞ÈÖç‰ø°: {filename}")
                return send_file(
                    voice_info['filepath'],
                    mimetype='audio/wav',
                    as_attachment=False,
                    download_name=filename
                )
        
        filepath = os.path.join(VOICE_DIR, filename)
        if os.path.exists(filepath):
            logger.info(f"üéµ „Éá„Ç£„Çπ„ÇØ„Åã„ÇâÈü≥Â£∞ÈÖç‰ø°: {filename}")
            return send_from_directory(VOICE_DIR, filename, mimetype='audio/wav')
        
        logger.warning(f"üîç Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: {filename}")
        return jsonify({'error': 'Voice file not found', 'filename': filename}), 404
        
    except Exception as e:
        logger.error(f"‚ùå Èü≥Â£∞ÈÖç‰ø°„Ç®„É©„Éº ({filename}): {e}", exc_info=True)
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/health')
def health_check():
    return jsonify({
        'status': 'healthy', 
        'voicevox_url': WORKING_VOICEVOX_URL,
        'web_search_enabled': True,
        'voice_cache_size': len(voice_cache),
        'stored_voice_files': len(voice_files)
    })

@app.route('/debug/voices')
def debug_voices():
    try:
        with voice_files_lock:
            memory_files = list(voice_files.keys())
        disk_files = os.listdir(VOICE_DIR) if os.path.exists(VOICE_DIR) else []
        return jsonify({'memory_files': memory_files, 'disk_files': disk_files, 'voice_dir': VOICE_DIR})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    host = os.environ.get('HOST', '0.0.0.0')
    os.makedirs(VOICE_DIR, exist_ok=True)
    logger.info(f"üéµ Èü≥Â£∞„Éá„Ç£„É¨„ÇØ„Éà„É™Ê∫ñÂÇôÂÆå‰∫Ü: {VOICE_DIR}")
    app.run(host=host, port=port, debug=False, threaded=True)
